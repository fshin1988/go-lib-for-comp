snippet     fprintln
abbr        fprintln
options     head
  fmt.Fprintln(wtr, ${1})

snippet     queue
abbr        queue
options     head
  type Node struct {
    x, y int
  }

  type Queue struct {
    arr []Node
  }

  func (q *Queue) push(v Node) {
    q.arr = append(q.arr, v)
  }

  func (q *Queue) pop() Node {
    res := q.arr[0]
    q.arr = q.arr[1:]
    return res
  }

  func (q *Queue) isEmpty() bool {
    return len(q.arr) == 0
  }

snippet     priorityQueue
abbr        priorityQueue
options     head
  type Element struct {
    id, cost int
  }

  type PQ []Element

  func (pq PQ) Len() int           { return len(pq) }
  func (pq PQ) Less(i, j int) bool { return pq[i].cost < pq[j].cost }
  func (pq PQ) Swap(i, j int)      { pq[i], pq[j] = pq[j], pq[i] }

  func (pq *PQ) Push(x interface{}) {
    *pq = append(*pq, x.(Element))
  }

  func (pq *PQ) Pop() interface{} {
    old := *pq
    n := len(old)
    x := old[n-1]
    *pq = old[0 : n-1]
    return x
  }

snippet     binarySearch
abbr        binarySearch
options     head
  ng := -1
  ok := len(a)
  for abs(ok-ng) > 1 {
    mid := (ok + ng) / 2
    if a[mid] >= key {
      ok = mid
    } else {
      ng = mid
    }
  }

snippet     unionFind
abbr        unionFind
options     head
  type UnionFind struct {
    parent []int
  }

  func NewUnionFind(n int) *UnionFind {
    p := make([]int, n)
    for i := 0; i < n; i++ {
      p[i] = i
    }
    return &UnionFind{p}
  }

  func (a *UnionFind) root(x int) int {
    if a.parent[x] == x {
      return x
    } else {
      a.parent[x] = a.root(a.parent[x])
      return a.parent[x]
    }
  }

  func (a *UnionFind) isSame(x, y int) bool {
    return a.root(x) == a.root(y)
  }

  func (a *UnionFind) unite(x, y int) {
    x = a.root(x)
    y = a.root(y)
    if x == y {
      return
    } else {
      a.parent[x] = y
    }
  }

snippet     bitSearch
abbr        bitSearch
options     head
  for bit := 0; bit < 1<<uint(n); bit++ {
    arr := make([]bool, n)
    for i := 0; i < n; i++ {
      if 1<<uint(i)&bit > 0 {
        arr[i] = true
      }
    }
    // Do something by using arr
  }


snippet     permutations
abbr        permutations
options     head
  func permutations(nums []int, n int) {
    var arr []int
    seen := make(map[int]bool)

    var search func(next int)
    search = func(next int) {
      arr = append(arr, next)
      seen[next] = true
      if len(arr) >= n {
        // Do something by using arr
        return
      }
      for _, next := range nums {
        if seen[next] {
          continue
        }
        search(next)
        arr = arr[:len(arr)-1]
        seen[next] = false
      }
    }
    for _, v := range nums {
      search(v)
      arr = arr[:len(arr)-1]
      seen[v] = false
    }
  }

snippet     divisor
abbr        divisor
options     head
  func divisor(n int) []int {
    res := []int{}
    for i := 1; i*i <= n; i++ {
      if n%i == 0 {
        res = append(res, i)
        if i*i != n {
          res = append(res, n/i)
        }
      }
    }
    return res
  }

snippet     primeFactors
abbr        primeFactors
options     head
  func primeFactors(n int) map[int]int {
    pfs := make(map[int]int)
    for n%2 == 0 {
      pfs[2]++
      n = n / 2
    }
    for i := 3; i*i <= n; i = i + 2 {
      for n%i == 0 {
        pfs[i]++
        n = n / i
      }
    }
    if n > 2 {
      pfs[n]++
    }

    return pfs
  }
